---
title: "Paralog Annotation Notes"
# output: rmarkdown::github_document
output: 
  pdf_document:
    toc: true
    number_sections: true
    fig_caption: yes
  #   keep_md: true
  #   theme: journal
  #   highlight: espresso
  #   fig_caption: yes
  # md_document:
  #   preserve_yaml: false
  #   fig_caption: yes
  # html_document:
editor_options: 
  chunk_output_type: inline
bibliography: bibliography.bib
always_allow_html: yes
---

<!--Load Packages and function-->
```{r echo=FALSE, message=FALSE, warning=FALSE, include=FALSE, results='hide'}
source("src/Paralogous_var_align_functions.R")
```

### Aims
* Apply Paralogue annotation on other datasets
    + "Genome Wide" - Clinvar dataset and ALL possible exome variants (get from `/data/Mirror/ExAC_release/release0.3.1/manuscript_data/all_possible_variants`)
    + Cardiomyopathy genes - [MYH7, MYBPC3, TNNT2, TPM1, MYL2, MYL3, TNNI3, ACTC1] -CHECK CODE TO SEE IF ALL MISSENSE CM VARIANTS REALLY DO NOT APPEAR IN ANY OF THESE GENES AS EG. MYH6 SHOULD HAVE SOME
    + Channelopathy genes - [KCNQ1, KCNH2, SCN5A, KCNE1, KCNE2, RYR2]
* Improve precision via increasing conservation of ref/alt alleles
    + pairwise QC - ignore any individual pairwise alignments where ref alleles are not conserved
    + pairwise QC and family QC - ignore entire alignment columns if the entire family ref alleles are not conserved; NB analogous to para z scores
    + pairwise QC and family QC and alt allele QC - ignore entire alignment columns if family ref allele and alt allele isn't conserved
* investigate para z scores
* investigate pfam meta domains

### Some interesting things to look at maybe
* "Ohnologs"
* Perform PA on paralogs from CPG (from @Modos2016) and non-CPG and see difference? 
* Integrating ortholog data to increase confidence calling 
* Gene Ontology packages - topGO?

### OBSTACLES TO GET DONE:
* For the number of variants being patho or benign, how many of them actually align to anther variant? At least ones within paralogues? Difference between patho and benign variants? - Basically how many annotations there are...
* Look at if patho set have more variants that lie in genes that have more paralogs than benign
* Make sure noQC, para_con, and all_con output files have consistent total beginning number of variants
* Look at situation where only alt allele are conserved but ignore ref allele entirely
* GO - Need to map distribution of variants back to the genome, probably only take a single paralogue family as example.
* Debugging plugin
    + Have fixed "Can't call methods: start/location_from_column" by implementing `if` loops to catch errors
        - check out RBM20 and its "2" paralogues (MATR3 and MATR3...) that were example of genes which variants were causing these problems.
        - apparently there are other genes that have this same pattern where there are multiple genes with the same gene symbol but different IDs - James believes there exists a list of these genes somewhere (maybe ask Emily?)
        - see if can get a list of consistent variants that cause these specific issues for Erica.
    + "MySQL error has gone away" error seems to now have been fixed with the help from emily
        - issues seem to be due to server timeouts from running long jobs
        - sent me https://www.ensembl.org/Help/Faq?id=567 for help
    + ask emily about MART3...?
* STILL HAVE YET TO ACCOUNT FOR CONFLICTING P/B VARIANTS IN SCRIPTS
* Take a look at forking option for VEP to run faster?
* Make a list and write down overlapping genes that cause an issue like MART3, where only one of the overlapping genes has info reported back. Write it as an appendix.
    + Either report back in output file as special results or maybe TAKE OUT error catching for "Can't call methods: start/location_from_column" errors and see if server still times out. That way warnings will be reported.
* All possible missense vcf for exome
    + be clear between all possible amino acid substitution and all possible nucleotide substitution
        - the sythetic exome from ExAC should contain all possible SNV
    + would be good to also write up stat for how many aa sub there is for every nt sub in report
* Xiaolei's all possible missense cm vcf does not contain all possible snv
* Need to get all possible missense for genome as well, I.e. get a vcf containing all possible nt sub, not just all possible aa sub! 
    + NEED TO MAKE MY OWN
* Rebenchmark with bigger test set (up to 100,000?)
    + edit the benchmarking script and rerun
* Get setup on imperial hpc and make sure plugin works
    + ~~setup perl api installation and make sure $PERL5LIB is correct; check erica chat history~~
    + ~~right installation instructions in github probably~~
    + run 30-38 failed, rerun
* ~~Data from denis~~ 
    + DONE - denis says that data I have is most up to date
    + DONE - Convert Para Z scores to 1 file for faster lookup and addition to tableize data.
* Data from henrike
    + waiting, will send me data when ready
* Web tool
    + Keep design simple
    + Ask Mark
* Make an experiment plan for transfering the framework over to structure space from sequence space
* Make all input data reproducible
* Look at bioconductor biomart package - easier to extract paralogue info from ensembl biomart

### Manuscript Plan
* New tool to show (more likely Erica will write up)
* Contrast to previous studies, is genome wide validated
* Describe implementation and how to use
    + vep plugin lib
* Provide additional descriptive statistics of input (clinvar) data, e.g. number of genes with paralogues, number of disease genes etc.
* Paralogue annotate P/LP with P/LP; paralogue annotate B/LB with P/LP
    + generate confusion matrices for above
* can PA also predict benign variants as well as pathogenic?
* does paraZ score add additional benefit
* additional test/validation dataset
    + disease - Henrike?
    + ExAC/gnomad
    + all possible snv - synthetic vcf
* ICC genes - EFs 
* Distributability 
    + plugin
    + R shiny - vep web tool; integrated browser
    + integrated into gnomad
* Pfam domains - separate paper?

#### Paper Layout 
**Abstract**

* *do last as usual...*

**Introduction**

* New variants are being rapidly discovered
* Ref previous papers and the work James/Roddy performed 
* Have developed a new tool for researchers to use - ref Erica's paper
* Have expanded this to bigger data sets/genome wide
* In this paper, will show how Paralogue Annotation can be used as a way of variant classification

**Material and Methods**

* Ref Ensembl and Erica's paper for VEP+plugin 
* Own pipeline (python/R)
* Data used
    + Ref clinvar
    + Ref Para Z scores
    + Ref Exac/Gnomad
        - all possible snv
    + Ref own clinical case/control cohorts
* statistical calculations
    + Precision/Sensitivity
    + EFs
* Webtool

**Results and Discussion**

* Additional descriptive statistics and background knowledge of below
* Analysis of Clinvar validation
    + pathogenic set
        - whole set; cardiomyopathy/channelopathy subset?
    + benign set (doesn't work)
    + Own filtering and Para Z scores improve precisions
* Analysis of EFs validation from OMIN data
* Gnomad/Exac
    + all possible snv
* Webtool
* Limitations
    + Quality of alignments
    + relianace on paralogues
        - reliance on variants in paralogues
* Solutions/Future Work
    + Different alignment algorithms?
    + (Don't mention Pfam meta domains specifically, but something along the lines of finding "optimal" homology)

**Conclusion**

* New variants being sequenced rapidly
* Concept of Paralogue Annotation works
* Novel idea of variant classification by homologous prediction
* Future work to be done

### Introduction
With the advancements of sequencing technology, new potential variants are being discovered constantly. However to be able to identify said variants as pathogenic or benign requires supporting evidence, which does not always exists especially if the variant novel. 
Previously Ware *et al.* have developed **Paralogue Annotation** [@Ware2012; @Walsh2014], which utilizes information from paralogues (evolutionarily related genes from the same species) to help classify pathogenic variants. They verified its use in LQTS genes on variants acquired from patient cohorts.

Here **Paralogue Annotation** is tested further on a (Likely) Pathogenic/Benign varaint dataset from Clinvar.

<span style="color:red">Also have a look at @Barshir2018 for more info about paralogs in diseases.</span>


### Material and Methods

The Paralog Annotation algorithm was wriiten by Erica as a perl script plugin (called __ParalogueAnno_plugin_cleanup.pm__) for Ensembl's VEP version 90 (https://www.ensembl.org/info/docs/tools/vep/script/vep_options.html). 

The plugin has two arguments:

* the first parameter has 2 options:
    + ```variant``` (default) returns only the paralogous variants if any are present in the associated paralogs of the query gene found in the ensembl compara database
    + ```paraloc``` returns only paralog variant locations in the form of genomic coordinates of the corresponding codon in ALL paralogs;
* the second parameter has 2 options:
    + ```all``` for all variants;
    +  ```damaging``` (default) for only damaging variant.
The majority of the time ```paraloc``` mode is used.

The Ensembl team have touched up Erica's plugin and decrease runtime. The plugin is now called __ParalogueAnnotation.pm__

The initial output by VEP and the Plugin (VEP+Plugin) is not reader friendly for either the user nor if you want to parse informations. So a python wrapper, shwon below, for the VEP+Plugin was written to automatically parse the results, namely the paralogous variant information - __/data/Share/nick/Paralog_Anno/VEP_ParalogAnno.py__(Note the code below is not polished for release and is a WIP).
```{python eval = FALSE, include = FALSE}
import  os, sys, subprocess, re
import shlex, subprocess

#WRAPPER FOR VEP+PLUGIN

def VEP_Plugin_run(flavour, input_dir, input_file, genome_build, VEPversion):
	# flavour = int(sys.argv[1])	#0(no plugin), 1(variants), 2(paraloc)
	# input_dir = sys.argv[2]	#input directory
	# input_file = sys.argv[3]	#name of input file
	# # output_file = sys.argv[3]	#name of output file
	# genome_build = str(sys.argv[4]) #37, 38
	# VEPversion = int(sys.argv[5]) #83, 87, 90

	#e.g. python3 VEP_ParalogAnno.py 0 /data/Share/nick/Paralog_Anno/data_files 10_pathogenic.vcf 38 90

	# if not len(os.listdir("/data/Share/nick/Paralog_Anno/homo_sapiens/")) == 0:
	# 	sys.exit("Terminating script:/data/Share/nick/Paralog_Anno/homo_sapiens/ not empty. Please empty and try again")

	# print(type(flavour))
	if flavour == 0:
		# print("check")
		flavour = ""
		output_file = input_file.rsplit(".",1)[0]+".out_no_plugin"
		print(output_file)
	# elif flavour == 1:
	# 	flavour = "--plugin ParalogueAnno_plugin_cleanup"
	# 	output_file = input_file.rsplit(".",1)[0]+".out_old"
	# 	print(output_file)
	# elif flavour == 2:
	# 	flavour = "--plugin ParalogueAnno_plugin_cleanup,paraloc"
	# 	output_file = input_file.rsplit(".",1)[0]+".out_old_paraloc"
	# 	print(output_file)
	# elif flavour == 3:
	# 	flavour = "--plugin ParalogueAnnotation"
	# 	output_file = input_file.rsplit(".",1)[0]+".out_new"
	# 	print(output_file)
	# elif flavour == 4:
	# 	flavour = "--plugin ParalogueAnnotation,paraloc"
	# 	output_file = input_file.rsplit(".",1)[0]+".out_new_paraloc"
	# 	print(output_file)
	elif flavour == 1:
		flavour = "--plugin ParalogueAnnotation"
		output_file = input_file.rsplit(".",1)[0]+".out"
		print(output_file)
	elif flavour == 2:
		flavour = "--plugin ParalogueAnnotation,paraloc"
		output_file = input_file.rsplit(".",1)[0]+".out_paraloc"
		print(output_file)

	# print(input_file)

	if not input_dir.endswith("/"):
		input_dir = input_dir+"/"
	print(input_dir)


	'''if VEPversion == 83:
		#VEP version 83
		# rm_command = ("rm -rf /data/Share/nick/Paralog_Anno/homo_sapiens/83_GRCh" + genome_build)
		mv_command = (
			"mv /data/Share/nick/Paralog_Anno/homo_sapiens_non_use/83_GRCh" + genome_build + " /data/Share/nick/Paralog_Anno/homo_sapiens"
			)
		command = (
			"perl -I /data/Install/ensembl-tools-release-83/scripts/variant_effect_predictor/.vep/Plugins /data/Install/ensembl-tools-release-83/scripts/variant_effect_predictor/variant_effect_predictor.pl --force_overwrite --vcf --offline --cache --dir_cache /data/Share/nick/Paralog_Anno/" +
			" -i " + input_dir + input_file +
			" -o " + input_dir + output_file + 
			" " + flavour
			)
		mv_back_command = (
			"mv /data/Share/nick/Paralog_Anno/homo_sapiens/83_GRCh" + genome_build + " /data/Share/nick/Paralog_Anno/homo_sapiens_non_use"
			)
	elif VEPversion == 87:
		#VEP version 87
		# rm_command = ("rm -rf /data/Share/nick/Paralog_Anno/homo_sapiens/87_GRCh" + genome_build)
		mv_command = (
			"mv /data/Share/nick/Paralog_Anno/homo_sapiens_non_use/87_GRCh" + genome_build + " /data/Share/nick/Paralog_Anno/homo_sapiens"
			)
		command = (
			"perl -I /data/Install/ensembl-tools-release-83/scripts/variant_effect_predictor/.vep/Plugins /data/Install/ensembl-tools-release-87/ensembl-tools/scripts/variant_effect_predictor/variant_effect_predictor.pl --force_overwrite --vcf --offline --cache --dir_cache /data/Share/nick/Paralog_Anno/" +
			" -i " + input_dir + input_file +
			" -o " + input_dir + output_file + 
			" " + flavour
			)
		mv_back_command = (
			"mv /data/Share/nick/Paralog_Anno/homo_sapiens/87_GRCh" + genome_build + " /data/Share/nick/Paralog_Anno/homo_sapiens_non_use"
			)'''
	if VEPversion == 90:
		#VEP version 90
		# rm_command = ("rm -rf /data/Share/nick/Paralog_Anno/homo_sapiens/90_GRCh" + genome_build)
		mv_command = (
			"mv /data/Share/nick/Paralog_Anno/homo_sapiens_non_use/90_GRCh" + genome_build + " /data/Share/nick/Paralog_Anno/homo_sapiens"
			)
		command = (
			# "perl -I /data/Install/ensembl-tools-release-83/scripts/variant_effect_predictor/.vep/Plugins /data/Install/ensembl-vep/vep --force_overwrite --vcf --offline --cache --dir_cache /data/Share/nick/Paralog_Anno/" +
			"perl -I /data/Share/nick/Paralog_Anno /data/Install/ensembl-vep/vep --force_overwrite --vcf --allele_number --offline --cache --dir_cache /data/Share/nick/Paralog_Anno/" +
			" -i " + input_dir + input_file +
			" -o " + input_dir + output_file + 
			" " + flavour
			)
		mv_back_command = (
			"mv /data/Share/nick/Paralog_Anno/homo_sapiens/90_GRCh" + genome_build + " /data/Share/nick/Paralog_Anno/homo_sapiens_non_use"
			)
	
	# print(mv_command)
	# os.system(mv_command)
	print(command)
	os.system(command)
	# print(mv_back_command)
	# os.system(mv_back_command)
	
	with open(
		input_dir + output_file + 
		"_summary.html"
		) as infile:
		for line in infile:
			if "<td>Run time</td>" in line:
				if VEPversion == 83 or VEPversion == 87:
					#IF VEP87 AND 83
					m = re.search(r"<td>Run time<\/td> <td>.*second.<\/td>", line)
					# print(m.group())
					run_time = m.group().split("</td> <td>")[1].rstrip("</td>")
					print(run_time, "\n")
				elif VEPversion == 90:
					# #IF VEP90
					m = re.search(r"<td>Run time<\/td><td>.*second.<\/td>", line)
					# print(m.group())
					run_time = m.group().split("</td><td>")[1].rstrip("</td>")
					print(run_time, "\n")

	###TESTED THE BELOW WITH VEP90#### MIGHT NOT WORK WITH OTHER VERSIONS
	#reads through outfile of vep+plugin and tidies up data by extracting only variants that have paralogs and spits that out as another outfile
	out_file = open(input_dir + output_file + "_paralogs", "w")
	if not flavour == "":
		with open(
			input_dir + output_file
			) as infile:
			for line in infile:
				if not line.startswith("#"):
					line = line.split("CSQ=")
					CSQ = line[0]
					print(CSQ)	#print query variant
					line = line[1].split(",")
					# print(line, "\n")
					for x in line:
						y = x.split("|")
						# print(y, "\n")
						gene = y[3]
						paralog = y[23]
						if paralog == "" or paralog == "\n":
							paralog_check = 0
						else:
							paralog_check = 1
						if paralog_check == 1:
							print(x, "\n")
							out_file.write(
								str(CSQ)+"PARALOGS->"
								+str(x)+"\n"
								)
				else:
					out_file.write(line)
	out_file.close()
	
	# ###FOR CLINVAR VARIANTS AT LEAST###SCRAP ALL OF THIS, USE R TIDYVERSE JOIN METHOD INSTEAD
	# out_file = open(input_dir + output_file + "_aligned_vars", "w")
	# with open(input_dir + output_file + "_paralogs") as infile1:
	# 	infile2 = open(input_dir + input_file, "r") 
	# 	text_list = infile2.read()
	# 	infile2.close()
	# 	####TEST_BELOW####
	# 	# chromosome = 1
	# 	# pos1 = 1050574
	# 	# pos2 = 1050575
	# 	# pos3 = 1050576
	# 	# s1 = re.findall("^"+str(chromosome)+"\t"+str(pos1)+"\s.*$", text_list, re.MULTILINE)
	# 	# s2 = re.findall("^"+str(chromosome)+"\t"+str(pos2)+"\s.*$", text_list, re.MULTILINE)
	# 	# s3 = re.findall("^"+str(chromosome)+"\t"+str(pos3)+"\s.*$", text_list, re.MULTILINE)		
	# 	# if s1:
	# 	# 	print("YES")
	# 	# 	print(s1)
	# 	# if s2:
	# 	# 	print(s2)
	# 	# if s3:
	# 	# 	print(s3)
	# 	####END_OF_TEST####
	# 	for line in infile1:
	# 		if not line.strip() == "":
	# 			query_variant = line.split("PARALOGS->")[0]
	# 			out_file.write(query_variant)
	# 			paralog_line = line.split("PARALOGS->")[1].rstrip()
	# 			paralog_line = paralog_line.split("|&")[1]
	# 			paralog_line = paralog_line.split("&")
	# 			paralog_line = list(filter(None, paralog_line))
	# 			print(paralog_line)
	# 			out_file.write(str(paralog_line)+";")
	# 			for paralog in paralog_line:
	# 				if not paralog == "":
	# 					print(paralog)
	# 					location = paralog.split(":")[1]
	# 					chromosome = location.split("_")[0].lstrip("chr")
	# 					position = location.split("_")[1]
	# 					position1 = int(position.split("-")[0])
	# 					position2 = int(position.split("-")[1])
	# 					positions = list(range(position1,position2+1))
	# 					print(chromosome, type(positions), positions)
	# 					# p = re.compile(r"^"+str(chromosome)+r"\t"+positions+r"\t")
	# 					for pos in positions:
	# 						s = re.findall("^"+str(chromosome)+"\t"+str(pos)+"\s.*$",text_list, re.MULTILINE)
	# 						if s:
	# 							print(s)
	# 							out_file.write(str(s)+";")
	# 			out_file.write("\n")
	# out_file.close()
	# #################################################
	
# VEP_Plugin_run(2, "/data/Share/nick/Paralog_Anno/data_files", "new_extracted_clinvar_cm_intepretated_raw_variants_2.vcf", "38", 87)


flavour = int(sys.argv[1])	#0(no plugin), 1(variants), 2(paraloc),
input_dir = sys.argv[2]	#input directory
input_file = sys.argv[3]	#name of input file
genome_build = str(sys.argv[4]) #37, 38
VEPversion = int(sys.argv[5]) #83, 87, 90
VEP_Plugin_run(flavour, input_dir, input_file, genome_build, VEPversion)
```

An intermediate python script (__File_prep_for_R.py__) was used to prep the results into R friendly data. Furthermore it could also be used to perform pairwise and family QC. Incidentally, the pairwise QC could be performed directly in R after the raw results are processed by __tableize_vcf.py__ and tabulated (see below).

__/data/Share/nick/Paralog_Anno/File_prep_for_R.py__ - formats results from __VEP_ParalogAnno.py__ into tabulated format ready for R processing
```{python eval = FALSE, include = FALSE}
import  os, sys, subprocess, re

#SCRIPT FOR SEPARATING EACH LINE IN VCF OUTPUT FROM VEP_PARALOGANNO.PY INTO TAB SEP FILE READY FOR JOIN IN R
#don't use if VEP_ParalogAnno.py has been edited to already do this, check to see if same code exists in that script
###BELOW ONLY WORKS FOR CLINVAR VCF FILES (EXAC HAS NO INFO IN ID VARIABLE)

input_file = sys.argv[1]	#path of VEP_ParalogAnno.py paralogs output file
dir1 = input_file.rsplit("/", 1)[0]
input_file2 = sys.argv[2]	#path of vcf file containing only orginal query variants list used as input for VEP_ParalogAnno.py. I.e. the very first input file!
refid_flavour = sys.argv[3] #whether to consider refID or not. 0: not, 1: only consider paralogous pair alignments where refID = 1, 2: only consider total gene family paralogous alignments where all refID in that family = 1

if refid_flavour == "noQC":
	out_file = open(input_file+"2.noQC", "w")
elif refid_flavour == "para_con":
	out_file = open(input_file+"2.para_con", "w")
elif refid_flavour == "all_con":
	out_file = open(input_file+"2.all_con", "w")

max_split = 0	#check to see max number of columns for R import as wide format
max_paralog_codons = ""
with open(input_file, "r") as f:
	for line in f:
		if line != "\n":
			# print(line)
			chrom = line.split()[0]
			position = line.split()[1]
			ID = line.split()[2]
			print(chrom+" "+position+"\t"+str(ID)+"\t")

			out_file.write(str(chrom)+" "+str(position)+"\t"+str(ID)+"\t")
			
			line = line.rstrip()
			paralog_codons = line.split("PARALOGS->")[1]
			paralog_codons = paralog_codons.split("|&")[1]
			paralog_codons = paralog_codons.split("&")
			# paralog_codons.pop(0)
			paralog_codons.remove("")
			print(paralog_codons)
			refid_flav2_check = 0
			if refid_flavour == "all_con":
				if all(refids.endswith("REFID=1") for refids in paralog_codons) == True:
					refid_flav2_check = 1

			for codon in paralog_codons:
				print(codon)

				if refid_flavour == "noQC" or refid_flav2_check == 1:
					refID = codon.split(":")[-1]
					print(refID)
					codon = codon.split(":")[1]
					paralog_chrom = codon.split("_")[0].lstrip("chr")
					paralog_position = int(codon.split("-")[1])
					print(
						str(paralog_chrom)+" "+str(paralog_position-2)+"\t"+
						str(paralog_chrom)+" "+str(paralog_position-1)+"\t"+
						str(paralog_chrom)+" "+str(paralog_position)+"\t"
						)

					out_file.write(
						str(paralog_chrom)+" "+str(paralog_position-2)+"\t"+
						str(paralog_chrom)+" "+str(paralog_position-1)+"\t"+
						str(paralog_chrom)+" "+str(paralog_position)+"\t"
						)

				if refid_flavour == "para_con":
					refID = codon.split(":")[-1]
					if refID == "REFID=1":
						print(refID)
						codon = codon.split(":")[1]
						paralog_chrom = codon.split("_")[0].lstrip("chr")
						paralog_position = int(codon.split("-")[1])
						print(
							str(paralog_chrom)+" "+str(paralog_position-2)+"\t"+
							str(paralog_chrom)+" "+str(paralog_position-1)+"\t"+
							str(paralog_chrom)+" "+str(paralog_position)+"\t"
							)

						out_file.write(
							str(paralog_chrom)+" "+str(paralog_position-2)+"\t"+
							str(paralog_chrom)+" "+str(paralog_position-1)+"\t"+
							str(paralog_chrom)+" "+str(paralog_position)+"\t"
							)

				# if refid_flavour == 2:
				# 	refID = 

			out_file.write("\n")

			if len(paralog_codons)*3 + 2 > max_split:
				max_split = len(paralog_codons)*3 + 2
				# print(len(paralog_codons))
				# print(paralog_codons)
				max_paralog_codons = paralog_codons
			# newline[1] = "\t".join(newline[1])
			# newline = "\t".join(newline)
			# out_file.write(newline)
	print(max_split, max_paralog_codons)	#number of columns for dataframe in R; + 2 for (chrom poistion) and (ID)
out_file.close()

if input_file2 != "null":
	if input_file2.endswith(".vcf"):
		out_file2 = open(input_file2+"_onlyVariantslist", "w")
		with open(input_file2, "r") as f:
			for line in f:
				if not line.startswith("#"):
					chrom = line.split()[0]
					position = line.split()[1]
					ID = line.split()[2]
					out_file2.write(str(chrom)+" "+str(position)+"\t"+str(ID)+"\n")
	# elif input_file2.endswith("out_paraloc"):
	# 	out_file2 = open(input_file2+"_onlyVariantslist", "w")
	# 	with open(input_file2, "r") as f:
	# 		for line in f:
	# 			if not line.startswith("#"):
	# 				chrom = line.split()[0]
	# 				position = line.split()[1]
	# 				ID = line.split()[2]
	# 				amino_acids = line.split("CSQ=")[1]

	# 				out_file2.write(str(chrom)+" "+str(position)+"\t"+str(ID)+"\n")
	out_file2.close()
```

As paraloc mode only returns ref alleles. The alt alleles were extracted from the VEP information. This was done by using __tableize_vcf.py__.
__/data/Share/nick/Paralog_Anno/loftee/src/tableize_vcf.py__ was used to format the VEP output into table format for R processing. For example:
```{bash eval = FALSE, include = TRUE}
python /data/Share/nick/Paralog_Anno/loftee/src/tableize_vcf.py --vcf /data/Share/nick/Paralog_Anno/data_files/clinvar_20171029_onlyPathogenic.out_paraloc --out /data/Share/nick/Paralog_Anno/data_files/clinvar_20171029_onlyPathogenic.out_paraloc_tableized --do_not_minrep --include_id --vep_info SYMBOL,Amino_acids,Codons,Paralogue_Vars --split_by_transcript --canonical_only
```

If __--split_by_transcript__ is used then the code above is sufficient. Otherwise a python wrapper that includes additional formatting (__/data/Share/nick/Paralog_Anno/Tableize_wrapper.py__) that tableize couldn't do, i.e. separate variants that had multiple REF and ALT alleles was used to prepare the data for R. 
```{python eval = FALSE, include = FALSE}
import  os, sys, subprocess, re

#Tableize.py wrapper plus additional formatting that can't be done in tableize

input_file = sys.argv[1]	#path of paraloc file e.g. /data/Share/nick/Paralog_Anno/data_files/clinvar_20171029_onlyPathogenic.out_paraloc
dir1 = input_file.rsplit("/", 1)[0]

os.system("python /data/Share/nick/Paralog_Anno/loftee/src/tableize_vcf.py --vcf " + input_file + " --out " + input_file + "_tableized --do_not_minrep --include_id --vep_info SYMBOL,Amino_acids,Codons,Paralogue_Vars")

out_file = open(input_file + "_tableized_temp", "w")
with open(input_file + "_tableized") as f:
	for line in f:
		line = line.split()
		AAs = line[7].split(",")
		for column in AAs:
			out_file.write(line[0] + "\t" + line[1] +"\t" +line[2] +"\t" + line[3] +"\t" +line[4] +"\t" +line[5] +"\t" + line[6] + "\t" + column + "\t" + line[8] + "\t" + line[9] + "\n")
out_file.close()

os.system("mv " + input_file + "_tableized_temp " + input_file + "_tableized")
```

It is worth noting that using VEP with different versions of perl will result in slight different outputs. The difference do not seem to be detrimental to the end result as it appears that only VEP is affect but not the Plugin.

#### Datasets
Clinvar Likely Pathogenic/Pathogenic and Likely Benign/Benign variant vcf files were extracted and downloaded via the method developed by Zhang *et al.* [@Zhang2017]. 

EFs calculated from OMGL and LMM datasets taken from previous @Walsh2017 publication.

Exac and Gnomad data from @Lek2016. 

For Gnomad run: 
```{r eval = FALSE}
library(DiagrammeR)
Gnomad_dataset_split = DiagrammeR::grViz("
digraph boxes_and_circles {
graph [overlap = true, fontsize = 10]

node [shape = plaintext, fillcolor = green, style=filled, fixedsize=false]
'RBH\ncluster: 9'; 'Imperial\nHPC: 29'; 'CX1\n(array): 19'; 'AX4\n(array): 10';

node [shape = plaintext, fillcolor = orange, style=filled, fixedsize=false]
'Total 38'; '1-9'; '10-19'; '20-29'; '30-38'

'Total 38' -> 'RBH\ncluster: 9'; 'Total 38' -> 'Imperial\nHPC: 29'; 'RBH\ncluster: 9' -> '1-9'; 'Imperial\nHPC: 29' -> 'CX1\n(array): 19'; 'CX1\n(array): 19' -> '10-19'; 'Imperial\nHPC: 29' -> 'AX4\n(array): 10'; 'AX4\n(array): 10' -> '20-29'; 'CX1\n(array): 19' -> '30-38'

}")
Gnomad_dataset_split
```

#### Benchmarking performance of the plugin

__/data/Share/nick/Paralog_Anno/multi_vcf_extractor_benchmark.py__ is used to demonstrate speed at which VEP+Plugin takes to run
```{python eval = FALSE, include = FALSE}
#Script for benchmarking VEP with different flavours by auto extracting set number of variants and running them

import os, sys, subprocess, re
sys.path.insert(0, "/data/Install/Python-3.6.3/")
from VEP_ParalogAnno import *
import numpy as np
import pandas as pd
from scipy import stats, integrate
import matplotlib.pyplot as plt
import seaborn as sns

file = sys.argv[1]	#e.g. data_files/ExAC.r1.sites.vep_onlySCN5A_GRCh38coords_wRefAl.vcf
dir1 = file.split("/")
onlyfile = dir1.pop()
dir1 = "/".join(dir1)
if not dir1.endswith("/"):
	dir1 = dir1+"/"

flavour = int(sys.argv[2]) #e.g 0
VEPversion = int(sys.argv[3]) #e.g. 90

x_list = list(range(100,1100,100))
x_list.append(10)
x_list.sort()
y_list = []

for x_var in x_list:
	input_file = str(onlyfile.rstrip(".vcf"))+".first"+str(x_var)+"lines.vcf"
	os.system("head -n"+str(x_var)+" "+str(dir1)+str(onlyfile)+" > "+str(dir1)+str(input_file))

	VEP_Plugin_run(
		flavour, 
		"/data/Share/nick/Paralog_Anno/data_files", 
		input_file,
		"38",
		VEPversion)

	if flavour == 0:
		output_file = input_file.rsplit(".",1)[0]+".out_no_plugin"
		print(output_file)
	elif flavour == 1:
		output_file = input_file.rsplit(".",1)[0]+".out"
		print(output_file)
	elif flavour == 2:
		output_file = input_file.rsplit(".",1)[0]+".out_paraloc"
		print(output_file)

	with open(
		dir1 + output_file + 
		"_summary.html"
		) as infile:
		for line in infile:
			if "<td>Run time</td>" in line:
				if VEPversion == 83 or VEPversion == 87:
					#IF VEP87 AND 83
					m = re.search(r"<td>Run time<\/td> <td>.*second.<\/td>", line)
					run_time = m.group().split("</td> <td>")[1].rstrip("</td>")
					print(run_time, "\n")
				elif VEPversion == 90:
					# #IF VEP90
					m = re.search(r"<td>Run time<\/td><td>.*second.<\/td>", line)
					run_time = m.group().split("</td><td>")[1].rstrip("</td>")
					print(run_time, "\n")
				y_list.append(int(run_time.split()[0]))

x_list = [0] + x_list
y_list = [0] + y_list
print(x_list)
print(y_list)


fig, ax = plt.subplots(figsize=(15,10))
axes = plt.gca()
plt.plot(x_list, y_list, 'ro')
plt.xlabel("Number of variants in query", fontsize=15)
plt.ylabel("Time taken (seconds)", fontsize=20)
if flavour == 0:
	plt.title("Time taken for VEP (no plugin) to run against number of varaints being searched")
elif flavour == 1:
	plt.title("Time taken for VEP (plugin in '-varaints' mode) to run against number of varaints being searched")
elif flavour == 2:
	plt.title("Time taken for VEP (plugin in '-paraloc' mode) to run against number of varaints being searched")
# plt.show()
plt.savefig(dir1+"benchmark_"+str(flavour)+"_"+str(VEPversion)+".png")
plt.gcf().clear()
```

#### Scripts pipeline

```{r eval = FALSE}
library(DiagrammeR)
pipeline = DiagrammeR::grViz("
digraph boxes_and_circles {
graph [overlap = true, fontsize = 10]

node [shape = plaintext, fillcolor = green, style=filled, fixedsize=false]
'VEP_ParalogAnno.py'; 'File_prep_for_R.py'; 'Tableize_wrapper.py'; 'R markdown'

node [shape = plaintext, fillcolor = orange, style=filled, fixedsize=false]
'vcf input file'; 'paralogs file'; 'paraloc file'; 'paralogs2 file'; 'paraloc_tableized file'

'vcf input file' -> 'VEP_ParalogAnno.py'; 'VEP_ParalogAnno.py' -> 'paralogs file'; 'VEP_ParalogAnno.py' -> 'paraloc file'; 'paralogs file' -> 'File_prep_for_R.py'; 'paraloc file' -> 'Tableize_wrapper.py'; 'File_prep_for_R.py' -> 'paralogs2 file'; 'Tableize_wrapper.py' -> 'paraloc_tableized file'; 'paralogs2 file' -> 'R markdown'; 'paraloc_tableized file' -> 'R markdown'

}")
pipeline
```

#### Statistical terms
In context of is there a pathogenic paralogue alignment? A TP = pathogenic query variant with a paralogous pathogenic hit; FP = benign query variant with a paralogous pathogenic hit; FN = pathogenic query variant with no paralogous pathogenic hit; and TN= benign query variant with no paralogous pathogenic hit.

Likewise for a benign paralogous alignment, a TP = benign query variant with a paralogous benign hit; FP = pathogenic query variant with a paralogous benign hit; FN = benign query variant with no paralogous benign hit; and TN = pathogenic query variant with no paralogous benign hit.

#### Annotation of Clinvar
The Clinvar file __clinvar_20171029.vcf__ was downloaded from ftp://ftp.ncbi.nlm.nih.gov/pub/clinvar/vcf_GRCh38/. Note that since the initial look at what was available there's been updated Clinvar files. 

NOTE that I have noticed some descrepencies between the plugin annotations which call REFID = 1/0 and that of comparing the REF amino acid by VEP in the dataset to itself. This is due to the fact that the paralogous variant VEP is referring to is simply not in the dataset that I am annotating back to. As a result, it is best to make sure that the ref alleles are indeed the same when processing in R.

The annotataion of the entire clinvar dataset as of March 2018 release (clinvar_alleles.single.b38.vcf.gz) was taken from https://github.com/macarthur-lab/clinvar/tree/master/output/b38/single. Different clinical significance definitions were subsetted using grep e.g:
```{bash eval = FALSE}
grep -P "CLINICAL_SIGNIFICANCE=Pathogenic" clinvar_alleles.single.b38.vcf > output1.vcf
grep -P "CLINICAL_SIGNIFICANCE=Likely_pathogenic" clinvar_alleles.single.b38.vcf > output2.vcf
cat output1.vcf output2.vcf > clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.vcf
```

Taking only the 5 channelopathy genes:
```{r eval = FALSE, include = FALSE}
Packages = c("tidyverse", "dplyr", "ggplot2", "ggsignif", "huxtable")
lapply(Packages, library, character.only = TRUE)
#noQC
#pathogenic to pathogenic
p.paralog_data = file("/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/clinvar_20171029_onlyPathogenic.out_paraloc_paralogs2.noQC")
max_no_col = (max(count.fields(p.paralog_data, sep = "\t"))-6) #-6 for "Variant_pos", "ID", "Gene", "Ref", "Alt", and "\n"
p.paralog_data = read.csv(file="/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/clinvar_20171029_onlyPathogenic.out_paraloc_paralogs2.noQC", sep="\t", header=FALSE, col.names = c("Variant_pos", "ID", "Gene", "REF", "ALT", paste("paralog", 1:max_no_col, sep = "")))
channelopathy_gene = c("KCNQ1","KCNH2","SCN5A","KCNE1","KCNE2","RYR2")
p.paralog_data = dplyr::filter(p.paralog_data, Gene %in% channelopathy_gene)
p.tableized_data = read.csv(file="/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/clinvar_20171029_onlyPathogenic.out_paraloc_tableized", sep = "\t", header=TRUE, stringsAsFactors=FALSE)
p.tableized_data$Variant_pos = paste(p.tableized_data$CHROM,p.tableized_data$POS, sep = " ")
p.tableized_data$REF_Amino_acids = sapply(p.tableized_data[,"Amino_acids"],strsplit, "/")
p.tableized_data$REF_Amino_acids = sapply(p.tableized_data[,"REF_Amino_acids"],unlist)
p.tableized_data$REF_Amino_acids = sapply(p.tableized_data[,"REF_Amino_acids"],function(x) x[1])
p.tableized_data$ALT_Amino_acids = sapply(p.tableized_data[,"Amino_acids"],strsplit, "/")
p.tableized_data$ALT_Amino_acids = sapply(p.tableized_data[,"ALT_Amino_acids"],unlist)
p.tableized_data$ALT_Amino_acids = sapply(p.tableized_data[,"ALT_Amino_acids"],function(x) x[2])
# p.tableized_data = p.tableized_data[,c("Variant_pos","ID","REF","ALT","REF_Amino_acids","ALT_Amino_acids","Codons")]
p.ref_data = p.tableized_data
p.paralog_data = left_join(p.paralog_data,p.tableized_data, by = c("Variant_pos" = "Variant_pos", "ID" = "ID"))
p.gathered_paralog_data = filter(gather(p.paralog_data, paralog, paralog_pos, paste("paralog", 1:132, sep = ""), factor_key = TRUE), paralog_pos != "")
ptop.Total_paralog_annotations = left_join(p.gathered_paralog_data,p.ref_data, by = c("paralog_pos" = "Variant_pos"))
ptop.num_of_paralog_anno = sum(!is.na(ptop.Total_paralog_annotations$ID.y))
#benign to pathogenic
b.paralog_data = read.csv(file="/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/clinvar_20171029_onlyBenign.out_paraloc_paralogs2.noQC", sep="\t", header=FALSE, col.names = c("Variant_pos", "ID", "Gene", paste("paralog", 1:132, sep = "")))
channelopathy_gene = c("KCNQ1","KCNH2","SCN5A","KCNE1","KCNE2","RYR2")
b.paralog_data = dplyr::filter(b.paralog_data, Gene %in% channelopathy_gene)
b.tableized_data = read.csv(file="/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/clinvar_20171029_onlyBenign.out_paraloc_tableized", sep = "\t", header=TRUE, stringsAsFactors=FALSE)
b.tableized_data$Variant_pos = paste(b.tableized_data$CHROM,b.tableized_data$POS, sep = " ")
b.tableized_data$REF_Amino_acids = sapply(b.tableized_data[,"Amino_acids"],strsplit, "/")
b.tableized_data$REF_Amino_acids = sapply(b.tableized_data[,"REF_Amino_acids"],unlist)
b.tableized_data$REF_Amino_acids = sapply(b.tableized_data[,"REF_Amino_acids"],function(x) x[1])
b.tableized_data$ALT_Amino_acids = sapply(b.tableized_data[,"Amino_acids"],strsplit, "/")
b.tableized_data$ALT_Amino_acids = sapply(b.tableized_data[,"ALT_Amino_acids"],unlist)
b.tableized_data$ALT_Amino_acids = sapply(b.tableized_data[,"ALT_Amino_acids"],function(x) x[2])
# b.tableized_data = b.tableized_data[,c("Variant_pos","ID","REF","ALT","REF_Amino_acids","ALT_Amino_acids","Codons")]
b.ref_data = b.tableized_data
b.paralog_data = left_join(b.paralog_data,b.tableized_data, by = c("Variant_pos" = "Variant_pos", "ID" = "ID"))
b.gathered_paralog_data = filter(gather(b.paralog_data, paralog, paralog_pos, paste("paralog", 1:132, sep = ""), factor_key = TRUE), paralog_pos != "")
btop.Total_paralog_annotations = left_join(b.gathered_paralog_data, p.ref_data, by = c("paralog_pos" = "Variant_pos"))
btop.num_of_paralog_anno = sum(!is.na(btop.Total_paralog_annotations$ID.y))
#stats
con_table_TP = ptop.num_of_paralog_anno
con_table_FP = btop.num_of_paralog_anno
con_table_TN = length(b.paralog_data$ID)-btop.num_of_paralog_anno
con_table_FN = length(p.paralog_data$ID)-ptop.num_of_paralog_anno
con_table_PPV = con_table_TP/(con_table_TP+con_table_FP)
con_table_Sensitivty = con_table_TP/(con_table_TP+con_table_FN)
con_table = matrix(
  c(length(p.paralog_data$ID),
    ptop.num_of_paralog_anno,
    length(b.paralog_data$ID),
    btop.num_of_paralog_anno
  ), ncol = 2
)
colnames(con_table) = c("Pathogenic", "Benign")
rownames(con_table) = c("Number of variants in total", "Number of variants predicted as pathogenic")
con_table_p_value = fisher.test(con_table)

#para_con
#pathogenic to pathogenic
p.paralog_data = read.csv(file="/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/clinvar_20171029_onlyPathogenic.out_paraloc_paralogs2.para_con", sep="\t", header=FALSE, col.names = c("Variant_pos", "ID", "Gene", paste("paralog", 1:132, sep = "")))
channelopathy_gene = c("KCNQ1","KCNH2","SCN5A","KCNE1","KCNE2","RYR2")
p.paralog_data = dplyr::filter(p.paralog_data, Gene %in% channelopathy_gene)
p.paralog_data = left_join(p.paralog_data,p.tableized_data, by = c("Variant_pos" = "Variant_pos", "ID" = "ID"))
p.gathered_paralog_data = filter(gather(p.paralog_data, paralog, paralog_pos, paste("paralog", 1:132, sep = ""), factor_key = TRUE), paralog_pos != "")
ptop.Total_paralog_annotations = left_join(p.gathered_paralog_data,p.ref_data, by = c("paralog_pos" = "Variant_pos"))
ptop.Total_paralog_annotations = ptop.Total_paralog_annotations[ptop.Total_paralog_annotations$REF_Amino_acids.x==ptop.Total_paralog_annotations$REF_Amino_acids.y,]
ptop.num_of_paralog_anno = sum(!is.na(ptop.Total_paralog_annotations$ID.y))
#benign to pathogenic
b.paralog_data = read.csv(file="/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/clinvar_20171029_onlyBenign.out_paraloc_paralogs2.para_con", sep="\t", header=FALSE, col.names = c("Variant_pos", "ID", "Gene", paste("paralog", 1:132, sep = "")))
channelopathy_gene = c("KCNQ1","KCNH2","SCN5A","KCNE1","KCNE2","RYR2")
b.paralog_data = dplyr::filter(b.paralog_data, Gene %in% channelopathy_gene)
b.paralog_data = left_join(b.paralog_data,b.tableized_data, by = c("Variant_pos" = "Variant_pos", "ID" = "ID"))
b.gathered_paralog_data = filter(gather(b.paralog_data, paralog, paralog_pos, paste("paralog", 1:132, sep = ""), factor_key = TRUE), paralog_pos != "")
btop.Total_paralog_annotations = left_join(b.gathered_paralog_data, p.ref_data, by = c("paralog_pos" = "Variant_pos"))
btop.Total_paralog_annotations = btop.Total_paralog_annotations[btop.Total_paralog_annotations$REF_Amino_acids.x==btop.Total_paralog_annotations$REF_Amino_acids.y,]
btop.num_of_paralog_anno = sum(!is.na(btop.Total_paralog_annotations$ID.y))
#stats
con_table2_TP = ptop.num_of_paralog_anno
con_table2_FP = btop.num_of_paralog_anno
con_table2_TN = length(b.paralog_data$ID)-btop.num_of_paralog_anno
con_table2_FN = length(p.paralog_data$ID)-ptop.num_of_paralog_anno
con_table2_PPV = con_table2_TP/(con_table2_TP+con_table2_FP)
con_table2_Sensitivty = con_table2_TP/(con_table2_TP+con_table2_FN)
con_table2 = matrix(
  c(length(p.paralog_data$ID),
    ptop.num_of_paralog_anno,
    length(b.paralog_data$ID),
    btop.num_of_paralog_anno
  ), ncol = 2
)
colnames(con_table2) = c("Pathogenic", "Benign")
rownames(con_table2) = c("Number of variants in total", "Number of variants predicted as pathogenic")
con_table2_p_value = fisher.test(con_table2)
#Variants_removed_after_PA_QC1
var_rem_para_con_TP = con_table[2]-con_table2[2]
var_rem_para_con_FP = con_table[4]-con_table2[4]
var_rem_para_con_FN = length(p.paralog_data$ID)-var_rem_para_con_TP
var_rem_para_con_PPV = var_rem_para_con_TP/(var_rem_para_con_TP+var_rem_para_con_FP)
var_rem_para_con_Sensitivity = var_rem_para_con_TP/(var_rem_para_con_TP+var_rem_para_con_FN)
var_rem_para_con = matrix(
  c(length(p.paralog_data$ID),
    var_rem_para_con_TP,
    length(b.paralog_data$ID),
    var_rem_para_con_FP
  ), ncol = 2
)
colnames(var_rem_para_con) = c("Pathogenic", "Benign")
rownames(var_rem_para_con) = c("Number of variants in total", "Number of variants predicted as pathogenic")
var_rem_para_con_p_value = fisher.test(var_rem_para_con)

#all_con
#pathogenic to pathogenic
p.paralog_data = read.csv(file="/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/clinvar_20171029_onlyPathogenic.out_paraloc_paralogs2.all_con", sep="\t", header=FALSE, col.names = c("Variant_pos", "ID", "Gene", paste("paralog", 1:132, sep = "")))
channelopathy_gene = c("KCNQ1","KCNH2","SCN5A","KCNE1","KCNE2","RYR2")
p.paralog_data = dplyr::filter(p.paralog_data, Gene %in% channelopathy_gene)
p.paralog_data = left_join(p.paralog_data,p.tableized_data, by = c("Variant_pos" = "Variant_pos", "ID" = "ID"))
p.gathered_paralog_data = filter(gather(p.paralog_data, paralog, paralog_pos, paste("paralog", 1:132, sep = ""), factor_key = TRUE), paralog_pos != "")
ptop.Total_paralog_annotations = left_join(p.gathered_paralog_data,p.ref_data, by = c("paralog_pos" = "Variant_pos"))
ptop.Total_paralog_annotations = ptop.Total_paralog_annotations[ptop.Total_paralog_annotations$REF_Amino_acids.x==ptop.Total_paralog_annotations$REF_Amino_acids.y,]
ptop.num_of_paralog_anno = sum(!is.na(ptop.Total_paralog_annotations$ID.y))
#benign to pathogenic
b.paralog_data = read.csv(file="/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/clinvar_20171029_onlyBenign.out_paraloc_paralogs2.all_con", sep="\t", header=FALSE, col.names = c("Variant_pos", "ID", "Gene", paste("paralog", 1:132, sep = "")))
channelopathy_gene = c("KCNQ1","KCNH2","SCN5A","KCNE1","KCNE2","RYR2")
b.paralog_data = dplyr::filter(b.paralog_data, Gene %in% channelopathy_gene)
b.paralog_data = left_join(b.paralog_data,b.tableized_data, by = c("Variant_pos" = "Variant_pos", "ID" = "ID"))
b.gathered_paralog_data = filter(gather(b.paralog_data, paralog, paralog_pos, paste("paralog", 1:132, sep = ""), factor_key = TRUE), paralog_pos != "")
btop.Total_paralog_annotations = left_join(b.gathered_paralog_data, p.ref_data, by = c("paralog_pos" = "Variant_pos"))
btop.Total_paralog_annotations = btop.Total_paralog_annotations[btop.Total_paralog_annotations$REF_Amino_acids.x==btop.Total_paralog_annotations$REF_Amino_acids.y,]
btop.num_of_paralog_anno = sum(!is.na(btop.Total_paralog_annotations$ID.y))
#stats
con_table3_TP = ptop.num_of_paralog_anno
con_table3_FP = btop.num_of_paralog_anno
con_table3_TN = length(b.paralog_data$ID)-btop.num_of_paralog_anno
con_table3_FN = length(p.paralog_data$ID)-ptop.num_of_paralog_anno
con_table3_PPV = con_table3_TP/(con_table3_TP+con_table3_FP)
con_table3_Sensitivty = con_table3_TP/(con_table3_TP+con_table3_FN)
con_table3 = matrix(
  c(length(p.paralog_data$ID),
    ptop.num_of_paralog_anno,
    length(b.paralog_data$ID),
    btop.num_of_paralog_anno
  ), ncol = 2
)
colnames(con_table3) = c("Pathogenic", "Benign")
rownames(con_table3) = c("Number of variants in total", "Number of variants predicted as pathogenic")
con_table3_p_value = fisher.test(con_table3)
#Variants_removed_after_PA_QC2
var_rem_all_con_TP = con_table2[2]-con_table3[2]
var_rem_all_con_FP = con_table2[4]-con_table3[4]
var_rem_all_con_FN = length(p.paralog_data$ID)-var_rem_all_con_TP
var_rem_all_con_PPV = var_rem_all_con_TP/(var_rem_all_con_TP+var_rem_all_con_FP)
var_rem_all_con_Sensitivity = var_rem_all_con_TP/(var_rem_all_con_TP+var_rem_all_con_FN)
var_rem_all_con = matrix(
  c(length(p.paralog_data$ID),
    var_rem_all_con_TP,
    length(b.paralog_data$ID),
    var_rem_all_con_FP
  ), ncol = 2
)
colnames(var_rem_all_con) = c("Pathogenic", "Benign")
rownames(var_rem_all_con) = c("Number of variants in total", "Number of variants predicted as pathogenic")
var_rem_all_con_p_value = fisher.test(var_rem_all_con)

#alt_con
#pathogenic to pathogenic
ptop.Total_paralog_annotations = ptop.Total_paralog_annotations[ptop.Total_paralog_annotations$ALT_Amino_acids.x==ptop.Total_paralog_annotations$ALT_Amino_acids.y,]
ptop.Total_paralog_annotations = ptop.Total_paralog_annotations[!duplicated(ptop.Total_paralog_annotations$ID.x),]
ptop.num_of_paralog_anno = sum(!is.na(ptop.Total_paralog_annotations$ID.y))
#benign to pathogenic
btop.Total_paralog_annotations = btop.Total_paralog_annotations[btop.Total_paralog_annotations$ALT_Amino_acids.x==btop.Total_paralog_annotations$ALT_Amino_acids.y,]
btop.Total_paralog_annotations = btop.Total_paralog_annotations[!duplicated(btop.Total_paralog_annotations$ID.x),]
btop.num_of_paralog_anno = sum(!is.na(btop.Total_paralog_annotations$ID.y))
#stats
con_table4_TP = ptop.num_of_paralog_anno
con_table4_FP = btop.num_of_paralog_anno
con_table4_TN = length(b.paralog_data$ID)-btop.num_of_paralog_anno
con_table4_FN = length(p.paralog_data$ID)-ptop.num_of_paralog_anno
con_table4_PPV = con_table4_TP/(con_table4_TP+con_table4_FP)
con_table4_Sensitivty = con_table4_TP/(con_table4_TP+con_table4_FN)
con_table4 = matrix(
  c(length(p.paralog_data$ID),
    ptop.num_of_paralog_anno,
    length(b.paralog_data$ID),
    btop.num_of_paralog_anno
  ), ncol = 2
)
colnames(con_table4) = c("Pathogenic", "Benign")
rownames(con_table4) = c("Number of variants in total", "Number of variants predicted as pathogenic")
con_table4_p_value = fisher.test(con_table4)
#Variants_removed_after_PA_QC3
var_rem_alt_con_TP = con_table3[2]-con_table4[2]
var_rem_alt_con_FP = con_table3[4]-con_table4[4]
var_rem_alt_con_FN = length(p.paralog_data$ID)-var_rem_alt_con_TP
var_rem_alt_con_PPV = var_rem_alt_con_TP/(var_rem_alt_con_TP+var_rem_alt_con_FP)
var_rem_alt_con_Sensitivity = var_rem_alt_con_TP/(var_rem_alt_con_TP+var_rem_alt_con_FN)
var_rem_alt_con = matrix(
  c(length(p.paralog_data$ID),
    var_rem_alt_con_TP,
    length(b.paralog_data$ID),
    var_rem_alt_con_FP
  ), ncol = 2
)
colnames(var_rem_alt_con) = c("Pathogenic", "Benign")
rownames(var_rem_alt_con) = c("Number of variants in total", "Number of variants predicted as pathogenic")
var_rem_alt_con_p_value = fisher.test(var_rem_alt_con)

#Overall_table
Variant = c("Pathogenic variants","Benign variants","PPV","Sensitivity","P value")
Total = c(length(p.paralog_data$ID),length(b.paralog_data$ID),"NA","NA","NA")
Paralogue_Annotation_no_QC = c(format(con_table[2], scientific = FALSE),format(con_table[4], scientific = FALSE),con_table2_PPV,con_table_Sensitivty,con_table_p_value$p.value)
Variants_remaining_after_PA_QC1 = c(format(con_table2[2], scientific = FALSE),format(con_table2[4], scientific = FALSE),con_table2_PPV,con_table2_Sensitivty,con_table2_p_value$p.value)
Variants_removed_after_PA_QC1 = c(var_rem_para_con[2],var_rem_para_con[4],var_rem_para_con_PPV,"NA",var_rem_para_con_p_value$p.value)
Variants_remaining_after_PA_QC2 = c(format(con_table3[2], scientific = FALSE),format(con_table3[4], scientific = FALSE),con_table3_PPV,con_table3_Sensitivty,con_table3_p_value$p.value)
Variants_removed_after_PA_QC2 = c(var_rem_all_con[2],var_rem_all_con[4],var_rem_all_con_PPV,"NA",var_rem_all_con_p_value$p.value)
Variants_remaining_after_PA_QC3 = c(format(con_table4[2], scientific = FALSE),format(con_table4[4], scientific = FALSE),con_table4_PPV,con_table4_Sensitivty,con_table4_p_value$p.value)
Variants_removed_after_PA_QC3 = c(var_rem_alt_con[2],var_rem_alt_con[4],var_rem_alt_con_PPV,"NA",var_rem_alt_con_p_value$p.value)

channelopathy_set = data.frame(Variant,
                               Total,
                               Paralogue_Annotation_no_QC,
                               Variants_remaining_after_PA_QC1,
                               Variants_removed_after_PA_QC1,
                               Variants_remaining_after_PA_QC2,
                               Variants_removed_after_PA_QC2,
                               Variants_remaining_after_PA_QC3,
                               Variants_removed_after_PA_QC3
                               )

```

On the other hand, channelopathy genes did annotate well suggesting that their paralogues are involved in disease. 

Looking at alt alleles. Taking only pairwise alignments where the alt allele is conserved leaves only 1115 individual pairwise alignments. The number of actual unique variants this equates to is less - 825.

#### Annotation of all possible missense variations in the 8 sarcomeric genes and calculation of EF

For calculating the EFs, run the all possible missense variants through VEP+plugin and return paraloc locations. Then join those locations with pathogenic clinvar variants as before. This indicates which variants from all possible missense variants are likely to be pathogenic. Then we check to see if any of these variants are present in the cases and controls. Hopefully the controls will be less but there is more control data than cases bare in mind. Calculate the EFs using that. Remember though the EFs are based on how many times an allele is seen, not the number of different alleles by themselves.


Total cases: 6140
number of affected cases: 39

Total controls: 60678
number of affected controls: 28

Odds ratio 	13.7648
95 % CI:	8.4648 to 22.3833
z statistic	10.570
Significance level	P < 0.0001
Attributable Risk Percent: 92.7% 
95 % CI: 79.6 to 100

#### Paralogue stats
The additional statistics were calculated by programmatically extracting the genes of interest (using `src/check_what_clinvar_genes.py` and `src/Find_unique_genes.py`) and then retrieving relevant information manually from [Ensembl's Bioimart](https://www.ensembl.org/biomart)

Alternatively, this can be reproduced using biomaRt package
                 
#### Para-Z scores
For the para-z scores, will need to extract amino acid position from VEP output as well. Then look up the gene in question in para-z score folder, and using the position identify the para-z score. From my understanding, the para-z score is the same across aligned amino acids in the same gene family. Therefore, we could use a cut-off threshold to further improve our confidence in calling variants pathogenic etc. We could also then calculate ROC curves by altering the cut-off to see how that affects sensitivity/PPV.

All available para-z scores were retreived from https://git-r3lab.uni.lu/genomeanalysis/paralogs/tree/master/data [@Lal2017]. Para-Z score cutoff thresholds were used to remove any annotation alignments in question. Amino Acid positions that had a para-z score below the chosen cutoff threshold were not used for annotations.

#### Ohnologs
The "2R"" hypothesis states that some 500 million years ago, early vertebrates went through 2 rounds of whole genome duplication (WGD)[@Ohno1968]. Paralogues that arose from this WGD are known as ohnologs. @Singh2014 showed that monogenic disease genes to be enriched in ohnologs than other paralogs that arose from small scale duplications.


### Results and Discussion

#### Paralogue stats

```{r paralog_dist, echo=FALSE, message=FALSE, warning=FALSE, fig.width=7,fig.height=6,fig.cap="\\label{fig:paralog_dist}Distribution of genes with paralogues by the number of paralogues they're related to"}
ensembl = useMart("ENSEMBL_MART_ENSEMBL", host = "jul2018.archive.ensembl.org")
ens_human <- useDataset("hsapiens_gene_ensembl",mart=ensembl)
protein_genes_w_paralogues = getBM(attributes = c("external_gene_name", "hsapiens_paralog_associated_gene_name"), filters = c("biotype", "with_hsapiens_paralog"), values = list("protein_coding", TRUE), mart = ens_human)
protein_genes_w_paralogues_genes = as.vector(unique(protein_genes_w_paralogues$external_gene_name))
# length(protein_genes_w_paralogues)
protein_genes_w_paralogues_wide = count(protein_genes_w_paralogues, external_gene_name)
colnames(protein_genes_w_paralogues_wide)[2] = "number_of_paralogues"
par(mfrow=c(2,2))
hist(protein_genes_w_paralogues_wide$number_of_paralogues, breaks = seq(0,50,1))

protein_genes_wo_paralogues = getBM(attributes = c("external_gene_name", "hsapiens_paralog_associated_gene_name"), filters = c("biotype", "with_hsapiens_paralog"), values = list("protein_coding", FALSE), mart = ens_human)
protein_genes_wo_paralogues_genes = as.vector(unique(protein_genes_wo_paralogues$external_gene_name))
# length(protein_genes_wo_paralogues)


#testing to see how many genes in the clinvar dataset have paralogues
clinvar_P_LP_tableized = read.csv(file="data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized", sep = "\t", header=TRUE, stringsAsFactors=FALSE)
clinvar_P_LP_tableized_genes = as.vector(unique(clinvar_P_LP_tableized$SYMBOL))
clinvar_B_LB_tableized = read.csv(file="data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized", sep = "\t", header=TRUE, stringsAsFactors=FALSE)
clinvar_B_LB_tableized_genes = as.vector(unique(clinvar_B_LB_tableized$SYMBOL))

#see if Patho and Benign sets have same distribution of variants in genes with paralogues
clinvar_P_LP_genes_w_paralogs = vector()
clinvar_P_LP_genes_wo_paralogs = vector()
clinvar_B_LB_genes_w_paralogs = vector()
clinvar_B_LB_genes_wo_paralogs= vector()
for (gene in clinvar_P_LP_tableized_genes){
  # print(gene)
  if (gene %in% protein_genes_w_paralogues_genes){
    clinvar_P_LP_genes_w_paralogs = c(gene, clinvar_P_LP_genes_w_paralogs)
  } else {
    clinvar_P_LP_genes_wo_paralogs = c(gene, clinvar_P_LP_genes_wo_paralogs)
  }
}
clinvar_P_LP_genes_w_paralogs_wide = protein_genes_w_paralogues_wide[protein_genes_w_paralogues_wide$external_gene_name %in% clinvar_P_LP_genes_w_paralogs,]
hist(clinvar_P_LP_genes_w_paralogs_wide$number_of_paralogues, breaks = seq(0,50,1))


for (gene in clinvar_B_LB_tableized_genes){
  # print(gene)
  if (gene %in% protein_genes_w_paralogues_genes){
    clinvar_B_LB_genes_w_paralogs = c(gene, clinvar_B_LB_genes_w_paralogs)
  } else {
    clinvar_B_LB_genes_wo_paralogs = c(gene, clinvar_B_LB_genes_wo_paralogs)
  }
}
clinvar_B_LB_genes_w_paralogs_wide = protein_genes_w_paralogues_wide[protein_genes_w_paralogues_wide$external_gene_name %in% clinvar_B_LB_genes_w_paralogs,]
hist(clinvar_B_LB_genes_w_paralogs_wide$number_of_paralogues, breaks = seq(0,50,1))

clinvar_P_LP_variants_wo_paralogs = vector()
for (variant in clinvar_P_LP_tableized$SYMBOL){
  if (variant %in% protein_genes_wo_paralogues_genes){
    clinvar_P_LP_variants_wo_paralogs = c(variant, clinvar_P_LP_variants_wo_paralogs)
  }
}

clinvar_B_LB_variants_wo_paralogs = vector()
for (variant in clinvar_B_LB_tableized$SYMBOL){
  if (variant %in% protein_genes_wo_paralogues_genes){
    clinvar_B_LB_variants_wo_paralogs = c(variant, clinvar_B_LB_variants_wo_paralogs)
  }
}

ks = ks.test(clinvar_P_LP_genes_w_paralogs_wide$number_of_paralogues, clinvar_B_LB_genes_w_paralogs_wide$number_of_paralogues)

# cap = "\\label{fig:paralog_dist}Distribution of genes with paralogues by the number of paralogues they're related to"
```

According to ensembl, `r length(protein_genes_w_paralogues_genes)` protein coding genes are defined to have paralogues. While `r length(protein_genes_wo_paralogues_genes)` protein coding genes did not have paralogues. Of those genes with paralogues (**fig.** \ref{fig:paralog_dist}a) the mean had `r round(mean(protein_genes_w_paralogues_wide$number_of_paralogues), 3)` paralogues with a standard deviation of `r round(sd(protein_genes_w_paralogues_wide$number_of_paralogues), 3)`. The maximum number of paralogues a gene had was `r max(protein_genes_w_paralogues_wide$number_of_paralogues)`.

In the clinvar pathogenic and likely pathogenic dataset, there were `r length(clinvar_P_LP_tableized$CHROM)` variants from `r length(clinvar_P_LP_tableized_genes)` genes. `r length(clinvar_P_LP_genes_wo_paralogs)` of these did not have paralogs and therefore the `r length(clinvar_P_LP_variants_wo_paralogs)` variants lying within these genes were not used for annotation, leaving `r length(clinvar_P_LP_tableized$CHROM) - length(clinvar_P_LP_variants_wo_paralogs)` for use in the analysis. The distribution of number of paralogues for these set of genes is shown in **fig.** \ref{fig:paralog_dist}b. The mean number of paralogues was `r round(mean(clinvar_P_LP_genes_w_paralogs_wide$number_of_paralogues), 3)` with a standard deviation `r round(sd(clinvar_P_LP_genes_w_paralogs_wide$number_of_paralogues), 3)`.

For variants in the clinvar benign and likely benign dataset, there were `r length(clinvar_B_LB_tableized$CHROM)` variants from `r length(clinvar_B_LB_tableized_genes)` genes. `r length(clinvar_B_LB_tableized$CHROM) - length(clinvar_B_LB_variants_wo_paralogs)` variants resided in `r length(clinvar_B_LB_genes_w_paralogs)` genes with paralogs. Their respective distribution is shown in **fig.** \ref{fig:paralog_dist}c, with a mean of `r round(mean(clinvar_P_LP_genes_w_paralogs_wide$number_of_paralogues), 3)` paralogues and a standard deviation of `r round(sd(clinvar_P_LP_genes_w_paralogs_wide$number_of_paralogues), 3)`.

Performing a simple kolmogorov smirnov test between the distribution of pathogenic variants in genes with paralogues and benign variants shows a p-value of `r ks$p.value` suggesting that the null hypothesis of the distributions being identical cannot be rejected. From this, there appears to be no statistical difference between pathogenic variants being more likely to lie in genes that have more paralogs compared to benign, at least in regards to the definitions of clinical significance made by clinvar.



#### Annotation of Clinvar
```{r clinvar_table, echo = FALSE, results='asis', message = FALSE, warning=FALSE, fig.width=7,fig.height=6,fig.cap="\\label{fig:clinvar_table}Total number of known P/LP variants and known B/LB variants predicted to be pathogenic"}
# library(knitr)
#noQC
#pathogenic to pathogenic
p.paralogous_var_align = Paralogous_var_align("data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_paralogs2.noQC", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
# p.paralogous_var_align = Paralogous_var_align("/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/clinvar_20171029_onlyPathogenic.out_paraloc_paralogs2.noQC", "/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/clinvar_20171029_onlyPathogenic.out_paraloc_tableized")
#benign to pathogenic
b.paralogous_var_align = Paralogous_var_align("data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_paralogs2.noQC", "data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
#pathogenic to benign
ptob.paralogous_var_align = Paralogous_var_align("data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_paralogs2.noQC", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized", "data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized")
#benign to benign
btob.paralogous_var_align = Paralogous_var_align("data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_paralogs2.noQC", "data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized")
#stats
conf = conf_matrix(p.paralogous_var_align$num_of_paralog_anno, p.paralogous_var_align$paralog_data, b.paralogous_var_align$num_of_paralog_anno, b.paralogous_var_align$paralog_data)
conf_b = conf_matrix_benign(ptob.paralogous_var_align$num_of_paralog_anno, ptob.paralogous_var_align$paralog_data, btob.paralogous_var_align$num_of_paralog_anno, btob.paralogous_var_align$paralog_data)

#para_con
p2.paralogous_var_align = Paralogous_var_align("data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_paralogs2.para_con", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
b2.paralogous_var_align = Paralogous_var_align("data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_paralogs2.para_con", "data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
ptob2.paralogous_var_align = Paralogous_var_align("data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_paralogs2.para_con", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized", "data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized")
btob2.paralogous_var_align = Paralogous_var_align("data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_paralogs2.para_con", "data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized")

conf2 = conf_matrix(p2.paralogous_var_align$num_of_paralog_anno, p2.paralogous_var_align$paralog_data, b2.paralogous_var_align$num_of_paralog_anno, b2.paralogous_var_align$paralog_data)
conf_b2 = conf_matrix_benign(ptob2.paralogous_var_align$num_of_paralog_anno, ptob2.paralogous_var_align$paralog_data, btob2.paralogous_var_align$num_of_paralog_anno, btob2.paralogous_var_align$paralog_data)

var_removed = var_rem_matrix(conf$con_table, conf2$con_table, p2.paralogous_var_align$paralog_data, b2.paralogous_var_align$paralog_data)

#all_con
p3.paralogous_var_align = Paralogous_var_align("data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_paralogs2.all_con", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
b3.paralogous_var_align = Paralogous_var_align("data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_paralogs2.all_con", "data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
ptob3.paralogous_var_align = Paralogous_var_align("data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_paralogs2.all_con", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized", "data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized")
btob3.paralogous_var_align = Paralogous_var_align("data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_paralogs2.all_con", "data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized")

conf3 = conf_matrix(p3.paralogous_var_align$num_of_paralog_anno, p3.paralogous_var_align$paralog_data, b3.paralogous_var_align$num_of_paralog_anno, b3.paralogous_var_align$paralog_data)
conf_b3 = conf_matrix_benign(ptob3.paralogous_var_align$num_of_paralog_anno, ptob3.paralogous_var_align$paralog_data, btob3.paralogous_var_align$num_of_paralog_anno, btob3.paralogous_var_align$paralog_data)

var_removed2 = var_rem_matrix(conf2$con_table, conf3$con_table, p3.paralogous_var_align$paralog_data, b3.paralogous_var_align$paralog_data)

#alt_con
#pathogenic to pathogenic
p4.Total_paralog_annotations = p3.paralogous_var_align$Total_paralog_annotations[p3.paralogous_var_align$Total_paralog_annotations$ALT_Amino_acids.x==p3.paralogous_var_align$Total_paralog_annotations$ALT_Amino_acids.y,]
# p4.Total_paralog_annotations = p4.Total_paralog_annotations[!duplicated(p4.Total_paralog_annotations$ID.x),]
p4.num_of_paralog_anno = sum(!is.na(p4.Total_paralog_annotations$ID.y))

#benign to pathogenic
b4.Total_paralog_annotations = b3.paralogous_var_align$Total_paralog_annotations[b3.paralogous_var_align$Total_paralog_annotations$ALT_Amino_acids.x==b3.paralogous_var_align$Total_paralog_annotations$ALT_Amino_acids.y,]
# b4.Total_paralog_annotations = b4.Total_paralog_annotations[!duplicated(b4.Total_paralog_annotations$ID.x),]
b4.num_of_paralog_anno = sum(!is.na(b4.Total_paralog_annotations$ID.y))

#pathogenic to benign
ptob4.Total_paralog_annotations = ptob3.paralogous_var_align$Total_paralog_annotations[ptob3.paralogous_var_align$Total_paralog_annotations$ALT_Amino_acids.x==ptob3.paralogous_var_align$Total_paralog_annotations$ALT_Amino_acids.y,]
ptob4.num_of_paralog_anno = sum(!is.na(ptob4.Total_paralog_annotations$ID.y))

#benign to benign
btob4.Total_paralog_annotations = btob3.paralogous_var_align$Total_paralog_annotations[btob3.paralogous_var_align$Total_paralog_annotations$ALT_Amino_acids.x==btob3.paralogous_var_align$Total_paralog_annotations$ALT_Amino_acids.y,]
btob4.num_of_paralog_anno = sum(!is.na(btob4.Total_paralog_annotations$ID.y))

conf4 = conf_matrix(p4.num_of_paralog_anno, p3.paralogous_var_align$paralog_data, b4.num_of_paralog_anno, b3.paralogous_var_align$paralog_data)
conf_b4 = conf_matrix_benign(ptob4.num_of_paralog_anno, ptob3.paralogous_var_align$paralog_data, btob4.num_of_paralog_anno, btob3.paralogous_var_align$paralog_data)

var_removed3 = var_rem_matrix(conf3$con_table, conf4$con_table, p3.paralogous_var_align$paralog_data, b3.paralogous_var_align$paralog_data)


#Overall_table
Variant = c("Pathogenic variants","Benign variants","PPV","Sensitivity","P value")
Total = c(length(p.paralogous_var_align$paralog_data$ID),length(b.paralogous_var_align$paralog_data$ID),"NA","NA","NA")
Paralogue_Annotation_no_QC = c(format(conf$con_table[2], scientific = FALSE),format(conf$con_table[4], scientific = FALSE),conf$PPV,conf$Sensitivity,conf$Pvalue$p.value)
Variants_remaining_after_PA_QC1 = c(format(conf2$con_table[2], scientific = FALSE),format(conf2$con_table[4], scientific = FALSE),conf2$PPV, conf2$Sensitivity, conf2$Pvalue$p.value)

Variants_removed_after_PA_QC1 = c(var_removed$con_table[2],var_removed$con_table[4],var_removed$PPV,"NA",var_removed$Pvalue$p.value)
Variants_remaining_after_PA_QC2 = c(format(conf3$con_table[2], scientific = FALSE),format(conf3$con_table[4], scientific = FALSE),conf3$PPV,conf3$Sensitivity,conf3$Pvalue$p.value)
Variants_removed_after_PA_QC2 = c(var_removed2$con_table[2],var_removed2$con_table[4],var_removed2$PPV,"NA",var_removed2$Pvalue$p.value)
Variants_remaining_after_PA_QC3 = c(format(conf4$con_table[2], scientific = FALSE),format(conf4$con_table[4], scientific = FALSE),conf4$PPV,conf4$Sensitivity,conf4$Pvalue$p.value)
Variants_removed_after_PA_QC3 = c(var_removed3$con_table[2],var_removed3$con_table[4],var_removed3$PPV,"NA",var_removed3$Pvalue$p.value)

# Paralogue_Annotation_no_QC = c(format(conf$con_table[2], scientific = FALSE),format(conf$con_table[4], scientific = FALSE),conf$PPV,conf$Sensitivity,conf$Pvalue$p.value)
# Variants_remaining_after_PA_QC1 = c(conf2$con_table[2],conf2$con_table[4],conf2$PPV, conf2$Sensitivity, conf2$Pvalue$p.value)
# 
# Variants_removed_after_PA_QC1 = c(var_removed$con_table[2],var_removed$con_table[4],var_removed$PPV,"NA",var_removed$Pvalue$p.value)
# Variants_remaining_after_PA_QC2 = c(conf3$con_table[2],conf3$con_table[4],conf3$PPV,conf3$Sensitivity,conf3$Pvalue$p.value)
# Variants_removed_after_PA_QC2 = c(var_removed2$con_table[2],var_removed2$con_table[4],var_removed2$PPV,"NA",var_removed2$Pvalue$p.value)
# Variants_remaining_after_PA_QC3 = c(conf4$con_table[2],conf4$con_table[4],conf4$PPV,conf4$Sensitivity,conf4$Pvalue$p.value)
# Variants_removed_after_PA_QC3 = c(var_removed3$con_table[2],var_removed3$con_table[4],var_removed3$PPV,"NA",var_removed3$Pvalue$p.value)

clinvar_set1 = data.frame(Variant,
                          Total,
                          Paralogue_Annotation_no_QC,
                          Variants_remaining_after_PA_QC1
                          )

clinvar_set2 = data.frame(Variants_removed_after_PA_QC1,
                          Variants_remaining_after_PA_QC2,
                          Variants_removed_after_PA_QC2
                          )

clinvar_set3 = data.frame(Variants_remaining_after_PA_QC3,
                          Variants_removed_after_PA_QC3)

kable(clinvar_set1)
kable(clinvar_set2)
kable(clinvar_set3)
```

Prior to annotation, there were `r length(clinvar_P_LP_tableized[!is.na(clinvar_P_LP_tableized$Paralogue_Vars),1])` variants that aligned to at least one paralogous equivalent position according to ensembl (`r length(clinvar_P_LP_tableized[!is.na(clinvar_P_LP_tableized$Paralogue_Vars),1])/length(clinvar_P_LP_tableized$CHROM)`)

The full analysis of clinvar variants is shown in **table \ref{fig:clinvar_table}**. In summary, `r conf$con_table[1]` Pathogenic and Likely Pathogenic (P/LP) variants and `r conf$con_table[2]` Benign and Likey Benign (B/LB) variants from clinvar had paralogue annotations. With no quality control, `r conf$con_table[2]` known P/LP  and `r conf$con_table[4]` known B/LB variants were predicted to be pathogenic, given a PPV and sensitivity of `r conf$PPV` and `r conf$Sensitivity` respectively. Comparatively, predicting benign variants was not as reliable. With `r conf_b$con_table[2]` known P/LP and `r conf_b$con_table[4]` known B/LB variants predicted to be benign. Though the proportional differene is statistically significant with a p-value of $`r conf_b$Pvalue$p.value`$, this lead to a PPV and sensitivity of `r conf_b$PPV` and `r conf_b$Sensitivity` respectively. 

Using the aforementioned quality control steps to increase the stringency of conservation across alignment columns in regards to reference and alternate amino acid alleles shows improvement to PPV and decrease in sensitivity over all for predicting pathogenic variants. But this does not help the case for predicting benign variants. The PPV does not improve significantly to a reliable level. Therefore, it can be concluded that at least with the dataset used in this study, paralogue annotation can be used as a variant classification method for predicting pathogenic variants, but not benign.



#### Para-Z scores

```{r message=FALSE, warning=FALSE, echo=FALSE}
Sensitivity_list = vector()
FPR_list = vector()
con_table_list = matrix(, ncol = 2)
for (i in seq(0,11)){
#noQC
#pathogenic to pathogenic
p.paraz_var_align = ParaZ_var_align(i,"data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_paralogs2.noQC", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
#benign to pathogenic
b.paraz_var_align = ParaZ_var_align(i,"data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_paralogs2.noQC", "data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
paraz.conf = conf_matrix(p.paraz_var_align$num_of_paralog_anno, p.paraz_var_align$paralog_data, b.paraz_var_align$num_of_paralog_anno, b.paraz_var_align$paralog_data)
Sensitivity_list = c(Sensitivity_list, paraz.conf$Sensitivity)
FPR_list = c(FPR_list, paraz.conf$FPR)
con_table_list = rbind(con_table_list, paraz.conf$con_table)
}
roc_data = do.call(rbind, Map(data.frame, Sensitivity = Sensitivity_list, FPR = FPR_list, cutoff = seq(0,11)))
gg = ggplot(roc_data, aes(x=FPR, y=Sensitivity, colour = cutoff)) + geom_point() + xlim(0,1) + ylim(0,1)
gg = gg + geom_abline(intercept = 0, slope = 1, linetype = "dotted")

ggplot(roc_data, aes(x=FPR, y=Sensitivity, colour = cutoff)) + geom_point() + xlim(0,0.04) + ylim(0.3,0.7) + scale_color_gradient(low="blue", high="red", limits=c(0, 11))


```


The filtering steps outlined above take a more binaray path into taking account the conservativeness of amino acid positions in the alignments. They only consider if amino acids in question share the the same amino acid or not. The Para-Z scores on the other hand take a more quantitative approach to this by representing a numeric integer value of how conserved each amino acid position is across the same paralogue family. Regardless both methods validate the concept that the more conserved amino acid positions are when transfering annotation the more likely annotations will be true positives as one would expect.

#### Subset of 8 sarcomeric genes and calculation of EF
Taking only the 8 sarcomeric genes:
```{r echo = FALSE, results='asis', warning=FALSE}
#noQC
p.sarco_var_align = Subset_var_align(c("MYH7","MYBPC3","TNNT2","TPM1","MYL2","MYL3","TNNI3","ACTC1"),"data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_paralogs2.noQC", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
b.sarco_var_align = Subset_var_align(c("MYH7","MYBPC3","TNNT2","TPM1","MYL2","MYL3","TNNI3","ACTC1"),"data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_paralogs2.noQC", "data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
conf = conf_matrix(p.sarco_var_align$num_of_paralog_anno, p.sarco_var_align$paralog_data, b.sarco_var_align$num_of_paralog_anno, b.sarco_var_align$paralog_data)
#para_con
p2.sarco_var_align = Subset_var_align(c("MYH7","MYBPC3","TNNT2","TPM1","MYL2","MYL3","TNNI3","ACTC1"),"data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_paralogs2.para_con", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
b2.sarco_var_align = Subset_var_align(c("MYH7","MYBPC3","TNNT2","TPM1","MYL2","MYL3","TNNI3","ACTC1"),"data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_paralogs2.para_con", "data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
conf2 = conf_matrix(p2.sarco_var_align$num_of_paralog_anno, p2.sarco_var_align$paralog_data, b2.sarco_var_align$num_of_paralog_anno, b2.sarco_var_align$paralog_data)

var_removed = var_rem_matrix(conf$con_table, conf2$con_table, p2.sarco_var_align$paralog_data, b2.sarco_var_align$paralog_data)

#all_con
p3.sarco_var_align = Subset_var_align(c("MYH7","MYBPC3","TNNT2","TPM1","MYL2","MYL3","TNNI3","ACTC1"),"data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_paralogs2.all_con", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
b3.sarco_var_align = Subset_var_align(c("MYH7","MYBPC3","TNNT2","TPM1","MYL2","MYL3","TNNI3","ACTC1"),"data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_paralogs2.all_con", "data/clinvar/clinvar_alleles.single.b38.Benign_and_LikelyBenign.out_paraloc_tableized", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
conf3 = conf_matrix(p3.sarco_var_align$num_of_paralog_anno, p3.sarco_var_align$paralog_data, b3.sarco_var_align$num_of_paralog_anno, b3.sarco_var_align$paralog_data)

var_removed2 = var_rem_matrix(conf2$con_table, conf3$con_table, p3.sarco_var_align$paralog_data, b3.sarco_var_align$paralog_data)

#alt_con
#pathogenic to pathogenic
p4.Total_paralog_annotations = p3.sarco_var_align$Total_paralog_annotations[p3.sarco_var_align$Total_paralog_annotations$ALT_Amino_acids.x==p3.sarco_var_align$Total_paralog_annotations$ALT_Amino_acids.y,]
# p4.Total_paralog_annotations = p4.Total_paralog_annotations[!duplicated(p4.Total_paralog_annotations$ID.x),]
p4.num_of_paralog_anno = sum(!is.na(p4.Total_paralog_annotations$ID.y))

#benign to pathogenic
b4.Total_paralog_annotations = b3.sarco_var_align$Total_paralog_annotations[b3.sarco_var_align$Total_paralog_annotations$ALT_Amino_acids.x==b3.sarco_var_align$Total_paralog_annotations$ALT_Amino_acids.y,]
# b4.Total_paralog_annotations = b4.Total_paralog_annotations[!duplicated(b4.Total_paralog_annotations$ID.x),]
b4.num_of_paralog_anno = sum(!is.na(b4.Total_paralog_annotations$ID.y))

conf4 = conf_matrix(p4.num_of_paralog_anno, p3.sarco_var_align$paralog_data, b4.num_of_paralog_anno, b3.sarco_var_align$paralog_data)

var_removed3 = var_rem_matrix(conf3$con_table, conf4$con_table, p3.sarco_var_align$paralog_data, b3.sarco_var_align$paralog_data)

#Overall_table
# Variant = c("Pathogenic variants","Benign variants","PPV","Sensitivity","P value")
# Total = c(length(p.sarco_var_align$paralog_data$ID),length(b.sarco_var_align$paralog_data$ID),"NA","NA","NA")
# Paralogue_Annotation_no_QC = c(format(conf$con_table[2], scientific = FALSE),format(conf$con_table[4], scientific = FALSE),conf$PPV,conf$Sensitivty,conf$Pvalue$p.value)
# Variants_remaining_after_PA_QC1 = c(format(conf2$con_table[2], scientific = FALSE),format(conf2$con_table[4], scientific = FALSE),conf2$PPV, conf2$Sensitivity, conf2$Pvalue$p.value)
# 
# Variants_removed_after_PA_QC1 = c(var_rem_para_con[2],var_rem_para_con[4],var_rem_para_con_PPV,"NA",var_rem_para_con_p_value$p.value)
# Variants_remaining_after_PA_QC2 = c(format(con_table3[2], scientific = FALSE),format(con_table3[4], scientific = FALSE),con_table3_PPV,con_table3_Sensitivty,con_table3_p_value$p.value)
# Variants_removed_after_PA_QC2 = c(var_rem_all_con[2],var_rem_all_con[4],var_rem_all_con_PPV,"NA",var_rem_all_con_p_value$p.value)
# Variants_remaining_after_PA_QC3 = c(format(con_table4[2], scientific = FALSE),format(con_table4[4], scientific = FALSE),con_table4_PPV,con_table4_Sensitivty,con_table4_p_value$p.value)
# Variants_removed_after_PA_QC3 = c(var_rem_alt_con[2],var_rem_alt_con[4],var_rem_alt_con_PPV,"NA",var_rem_alt_con_p_value$p.value)
# 
# sarcomeric_set = data.frame(Variant,
#                                Total,
#                                Paralogue_Annotation_no_QC,
#                                Variants_remaining_after_PA_QC1,
#                                Variants_removed_after_PA_QC1,
#                                Variants_remaining_after_PA_QC2,
#                                Variants_removed_after_PA_QC2,
#                                Variants_remaining_after_PA_QC3,
#                                Variants_removed_after_PA_QC3
#                                )

#Overall_table
Variant = c("Pathogenic variants","Benign variants","PPV","Sensitivity","P value")
Total = c(length(p.sarco_var_align$paralog_data$ID),length(b.sarco_var_align$paralog_data$ID),"NA","NA","NA")
Paralogue_Annotation_no_QC = c(format(conf$con_table[2], scientific = FALSE),format(conf$con_table[4], scientific = FALSE),conf$PPV,conf$Sensitivity,conf$Pvalue$p.value)
Variants_remaining_after_PA_QC1 = c(format(conf2$con_table[2], scientific = FALSE),format(conf2$con_table[4], scientific = FALSE),conf2$PPV, conf2$Sensitivity, conf2$Pvalue$p.value)

Variants_removed_after_PA_QC1 = c(var_removed$con_table[2],var_removed$con_table[4],var_removed$PPV,"NA",var_removed$Pvalue$p.value)
Variants_remaining_after_PA_QC2 = c(format(conf3$con_table[2], scientific = FALSE),format(conf3$con_table[4], scientific = FALSE),conf3$PPV,conf3$Sensitivity,conf3$Pvalue$p.value)
Variants_removed_after_PA_QC2 = c(var_removed2$con_table[2],var_removed2$con_table[4],var_removed2$PPV,"NA",var_removed2$Pvalue$p.value)
Variants_remaining_after_PA_QC3 = c(format(conf4$con_table[2], scientific = FALSE),format(conf4$con_table[4], scientific = FALSE),conf4$PPV,conf4$Sensitivity,conf4$Pvalue$p.value)
Variants_removed_after_PA_QC3 = c(var_removed3$con_table[2],var_removed3$con_table[4],var_removed3$PPV,"NA",var_removed3$Pvalue$p.value)

sarcomeric_set = data.frame(Variant,
                               Total,
                               Paralogue_Annotation_no_QC,
                               Variants_remaining_after_PA_QC1,
                               Variants_removed_after_PA_QC1,
                               Variants_remaining_after_PA_QC2,
                               Variants_removed_after_PA_QC2,
                               Variants_remaining_after_PA_QC3,
                               Variants_removed_after_PA_QC3
                               )
kable(sarcomeric_set)

```

There are however limitations to this current framework. These can be listed as the following criteria: 1)the reliance on genes with paralogues; 2) for those paralogues to have pathogenic variants; and 3) for the paralogous variants to be aligned to corresponding equivalent positions. This is not always the case. 

As a specific example, consider Hypertrophic Cardiomyopathy (HCM) and the 8 sarcomeric genes commonly associated with the genetic basis of HCM: MYH7; MYBPC3; TNNT2; TPM1; MYL2; MYL3; TNNI3; and ACTC1.

Annotating only these 8 sarcomeric genes with the whole clinvar P/LP dataset as before did not provide many annotations - without any quality control there were only `r sarcomeric_set$Paralogue_Annotation_no_QC[1]` P/LP variants and `r sarcomeric_set$Paralogue_Annotation_no_QC[2]` B/LP variants predicted to be pathogenic.

This could suggest either PA does not perform well on sarcomeric genes for the reasons stated above (paralogues to sarcomeric genes are not involed in disease) or that there is a lack of data - given more pathogenic variants to annotate with would certainly increase the likelihood of paralogous alignments. 

```{r sarco_para, echo=FALSE, message=FALSE, warning=FALSE, fig.width=7,fig.height=6,fig.cap="\\label{fig:sarco_para}Number of paralogues each sarcomeric gene has"}
ensembl = useMart("ENSEMBL_MART_ENSEMBL", host = "jul2018.archive.ensembl.org")
ens_human <- useDataset("hsapiens_gene_ensembl",mart=ensembl)
gene_id = c("MYH7", "MYBPC3", "TNNT2", "TPM1", "MYL2", "MYL3", "TNNI3", "ACTC1")

sarcomeric_genes = getBM(attributes = c("external_gene_name",
                                                  "hsapiens_paralog_associated_gene_name"), 
                                   filters = c("biotype", "with_hsapiens_paralog", "external_gene_name"), 
                                   values = list("protein_coding", TRUE, gene_id), mart = ens_human)

clinvar_P_LP_tableized = read.csv(file="data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized", sep = "\t", header=TRUE, stringsAsFactors=FALSE)

sarcomeric_variants = data.frame(Doubles=double(),
                                         Ints=integer(),
                                         Factors=factor(),
                                         Logicals=logical(),
                                         Characters=character(),
                                         stringsAsFactors=FALSE)
count = 1
for (variant in clinvar_P_LP_tableized$SYMBOL){
  if (variant %in% gene_id){
    sarcomeric_variants = rbind(sarcomeric_variants, clinvar_P_LP_tableized[count,])
  }
  count = count + 1
}

sarcomeric_paralog_variants = data.frame(Doubles=double(),
                                         Ints=integer(),
                                         Factors=factor(),
                                         Logicals=logical(),
                                         Characters=character(),
                                         stringsAsFactors=FALSE)
count = 1
for (variant in clinvar_P_LP_tableized$SYMBOL){
  if (variant %in% sarcomeric_genes$hsapiens_paralog_associated_gene_name){
    sarcomeric_paralog_variants = rbind(sarcomeric_paralog_variants, clinvar_P_LP_tableized[count,])
  }
  count = count + 1
}

# sarcomeric_genes_paralogs = spread(sarcomeric_genes, key = "hsapiens_paralog_associated_gene_name", "hsapiens_paralog_associated_gene_name")

sarcomeric_genes_paralogs = sarcomeric_genes %>%
  group_by(external_gene_name) %>%
  summarise(total = toString(hsapiens_paralog_associated_gene_name)) %>%
  ungroup()



kable(sarcomeric_genes_paralogs)
#kable(sarcomeric_paralog_variants)
```

Looking at how many paralogues the 8 sarcomeric genes have (table `sarcomeric_genes_paralogs`), there are at least 2 for each gene with MYH7 having the most - 13. This satisfies the first criteria.

In the clinvar P/LP dataset, there are `r length(sarcomeric_variants$CHROM)` known P/LP variants that lie in the 8 sarcomeric genes. But taking only the paralogues of these genes, there are only `r length(sarcomeric_paralog_variants$CHROM)` variants. Assuming the clinvar dataset is complete and considering it in isolation, this would suggest that in comparison to variants in the main 8 sarcomeric genes involved in HCM, their associated paralogous variants are not as frequently involved in disease. This still does however statisfy the second criteria.

Therefore, the third criteria is where the lack of as many annotations arises.

Therefore, it is not yet certain that PA does not work on sarcomeric genes and annotataion of additional sarcomeric data is required. See below.

```{r eval = FALSE, include = FALSE}
#noQC
#all missense data
# art.paralogous_var_align = Paralogous_var_align("/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/all_possible_mutation_icc/remapped_cm_mutation_vep_canon_wRefAl.out_paraloc_paralogs2.noQC", "/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/all_possible_mutation_icc/remapped_cm_mutation_vep_canon_wRefAl.out_paraloc_tableized", "/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
art.paralogous_var_align = Paralogous_var_align_compressed("data/all_possible_mutations/remapped_cm_mutation_vep_canon_wRefAl.out_paraloc_paralogs2.noQC.gz", "data/all_possible_mutations/remapped_cm_mutation_vep_canon_wRefAl.out_paraloc_tableized.gz", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
patho_art_var = art.paralogous_var_align$Total_paralog_annotations[!is.na(art.paralogous_var_align$Total_paralog_annotations$ID.y),]
#case data
case.data = read.csv("data/case_and_control/remapped_HCM_missense_LMM_OMGL_chr_wRefAl.vcf", sep = "\t", skip = 4)
case.data$Variant_pos = paste(case.data$X.CHROM, case.data$POS, sep = " ")
patho_case.data = case.data[case.data$Variant_pos %in% patho_art_var$Variant_pos,]
#control data
control.data = read.csv("data/case_and_control/remapped_ExAC_missense_sarcomeric_chr_wRefAl.vcf", sep = "\t", skip = 4)
control.data$Variant_pos = paste(control.data$X.CHROM, control.data$POS, sep = " ")
patho_control.data = control.data[control.data$Variant_pos %in% patho_art_var$Variant_pos,]

#case data VEP
case.paralogous_var_align = Paralogous_var_align("data/case_and_control/remapped_HCM_missense_LMM_OMGL_chr_wRefAl.out_paraloc_paralogs2.noQC", "data/case_and_control/remapped_HCM_missense_LMM_OMGL_chr_wRefAl.out_paraloc_tableized", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
patho_case_var = case.paralogous_var_align$Total_paralog_annotations[!is.na(case.paralogous_var_align$Total_paralog_annotations$ID.y),]
patho_case_var_IDs = patho_case_var$ID.x
# write(patho_case_var_IDs, file = "/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/case_controls/patho_case_var_IDs.txt", sep = "\t", ncolumns = 1)
case.data = read.csv("data/case_and_control/HCM_missense_LMM_OMGL_chr.csv", sep = ",")
patho_case.data = case.data[case.data$mut_id %in% patho_case_var_IDs,]
case_cases = sum(patho_case.data$sum.vs_case_count.)
Total_case_cases = sum(case.data$sum.vs_case_count.)

#control data VEP
control.paralogous_var_align = Paralogous_var_align("data/case_and_control/remapped_ExAC_missense_sarcomeric_chr_wRefAl.out_paraloc_paralogs2.noQC", "data/case_and_control/remapped_ExAC_missense_sarcomeric_chr_wRefAl.out_paraloc_tableized", "data/clinvar/clinvar_alleles.single.b38.Pathogenic_and_LikelyPathogenic.out_paraloc_tableized")
patho_control_var = control.paralogous_var_align$Total_paralog_annotations[!is.na(control.paralogous_var_align$Total_paralog_annotations$ID.y),]
patho_control_var_IDs = patho_control_var$ID.x
# write(patho_control_var_IDs, file = "/media/nick/Data/Users/N/Documents/PhD/Paralogues/data_files/case_controls/patho_control_var_IDs.txt", sep = "\t", ncolumns = 1)
control.data = read.csv("data/case_and_control/ExAC_missense_sarcomeric_chr.csv", sep = ",")
patho_control.data = control.data[control.data$mut_id %in% patho_control_var_IDs,]
control_cases = sum(patho_control.data$mut_exac_count)
Total_control_cases = sum(control.data$mut_exac_count)

```

 

For example in the 8 sarcomeric genes involved in HCM [MYH7, MYBPC3, TNNT2, TPM1, MYL2, MYL3, TNNI3, ACTC1], taking MYH7 there were not many paralogous alignments.   since most paralogues of HCM disease genes are no.

Infact performing the analysis on all possible missesnse mutations for these set of genes still shows a lack of annotation...

Hence we calculated EFs in order to see for those few variants that are predicted to be pathogenic, how often do they appear to be causative of disease in a disease cohort case control study. Segway to HCM validation.


#### References